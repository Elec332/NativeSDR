include(CMakeParseArguments)

function(addProject type)
    getSources()

    #Lib type mapper
    if ((${type} STREQUAL LIB) OR (${type} STREQUAL LIBRARY))
        if ((DEFINED ARGV1) AND ((${ARGV1} STREQUAL SHARED) OR (${ARGV1} STREQUAL STATIC)))
            set(type ${ARGV1})
        else()
            message(FATAL_ERROR "No/invalid lib type defined")
        endif()
    endif()

    #Lib or executable
    if ((${type} STREQUAL SHAREDLIB) OR (${type} STREQUAL SHARED))
        add_library(${PROJECT_NAME} SHARED ${SRC} ${SRC_C})
        withExportHeaders()
        importSharedLibraries()
    elseif((${type} STREQUAL STATICLIB) OR (${type} STREQUAL STATIC))
        add_library(${PROJECT_NAME} STATIC ${SRC} ${SRC_C})
    elseif(${type} STREQUAL EXEC)
        add_executable(${PROJECT_NAME} ${SRC} ${SRC_C})
        importSharedLibraries()
    else()
        message(FATAL_ERROR "Invalid project type: ${type}")
    endif ()

    addIncludeDirectories()
    processAssets()
endfunction()

macro(getSources)
    file(GLOB_RECURSE SRC src/cpp/*.cpp src/cpp/*.c src/cpp/*.hpp src/cpp/*.h)
    file(GLOB_RECURSE SRC_C src/cpp/*.c src/c/*.h)
    set_source_files_properties(${SRC} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRC_C} PROPERTIES LANGUAGE C)
endmacro()

macro(addIncludeDirectories)
    target_include_directories(${PROJECT_NAME} PRIVATE src/headers)
    target_include_directories(${PROJECT_NAME} PUBLIC src/public)
endmacro()

macro(processAssets)
    #Assets
    if (DEFINED ASSET_DIR)
        set(ASSET_DIR assets)
    endif ()
    #todo: Force-overwrite assets. Install DIRECTORY doesnt do this, but install FILES doesnt do so either
    if(EXISTS ${PROJECT_SOURCE_DIR}/assets/)
        file(GLOB files "assets/*.*")
        foreach(file ${files})
            install(FILES "${file}" DESTINATION assets)
        endforeach()
    endif()
endmacro()

macro(withExportHeaders)
    include(GenerateExportHeader)
    generate_export_header(${PROJECT_NAME})
    target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_BINARY_DIR})
endmacro()

function(installRuntime)
    if (DEFINED ARGV0)
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION ${ARGV0})
    else()
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION /)
    endif()
endfunction()

macro(setCentralOutput)
    SET(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
    SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
endmacro()

macro(importSharedLibraries)
    if(NOT (${CMAKE_VERSION} VERSION_LESS "3.20"))
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_RUNTIME_DLLS:${PROJECT_NAME}> $<TARGET_FILE_DIR:${PROJECT_NAME}> COMMAND_EXPAND_LISTS)
    endif()
endmacro()

macro(forceX64)
    if(MSVC)
        set(CMAKE_GENERATOR_PLATFORM x64)
    endif()
endmacro()

#####################################################
## Libraries
#####################################################

function(useLibrary name)
    cmake_parse_arguments(ULB "PUBLIC" "" "" ${ARGN})
    if(ULB_PUBLIC)
        target_link_libraries(${PROJECT_NAME} PUBLIC ${name})
    else()
        target_link_libraries(${PROJECT_NAME} PRIVATE ${name})
    endif()
endfunction()

function(useHeaderLibrary name)
    cmake_parse_arguments(UHLB "PRIVATE" "" "" ${ARGN})
    if(UHLB_PRIVATE)
        target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    else()
        target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    endif()
endfunction()

function(createStaticLibrary name)
    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        cmake_parse_arguments(CSL "USE;PUBLIC" "LIB;LIBD" "" ${ARGN})
        add_library(${name} STATIC IMPORTED)
        set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")

        if(CSL_LIB)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${CSL_LIB}.lib")
        else()
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${name}.lib")
        endif()

        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        #todo: Linux ect
    endif()
endfunction()

function(createSharedLibrary name)
    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        cmake_parse_arguments(CSL "USE;PUBLIC" "DLL;LIB;DLLD;LIBD;FILE;FILED;INSTALL" "" ${ARGN})
        add_library(${name} SHARED IMPORTED)
        set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")

        if(CSL_DLL)
            set(CSL_DLL_FILE ${CSL_DLL}.dll)
        else()
            if(CSL_FILE)
                set(CSL_DLL_FILE ${CSL_FILE}.dll)
            else()
                set(CSL_DLL_FILE ${name}.dll)
            endif()
        endif()
        set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/bin/${CSL_DLL_FILE}")
        if(CSL_INSTALL)
            install(FILES "${csl_root}/bin/${CSL_DLL_FILE}" DESTINATION ${CSL_INSTALL})
        endif()

        if(CSL_LIB)
            set(CSL_LIB_FILE ${CSL_LIB}.lib)
        else()
            if(CSL_FILE)
                set(CSL_LIB_FILE ${CSL_FILE}.lib)
            else()
                set(CSL_LIB_FILE ${name}.lib)
            endif()
        endif()
        set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB "${csl_root}/lib/${CSL_LIB_FILE}")

        if(CSL_DLLD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_DLLD}.dll")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_FILED}.dll")
        endif()
        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_FILED}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        #todo: Linux ect
    endif()
endfunction()

#####################################################
## GTest
#####################################################

macro(fetchGTest)
    if (NOT DEFINED ENABLE_UNIT_TESTS)
        option(ENABLE_UNIT_TESTS "Enable unit tests" ON)
    endif()
    message(STATUS "Enable testing: ${ENABLE_UNIT_TESTS}")
    if (ENABLE_UNIT_TESTS)
        include(FetchContent)
        cmake_parse_arguments(AGT "" "FILE;VERSION" "" ${ARGN})
        if(AGT_VERSION)
            FetchContent_Declare(googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG ${AGT_VERSION})
        elseif(AGT_FILE)
            FetchContent_Declare(googletest URL file://${PROJECT_SOURCE_DIR}/${AGT_FILE})
        else()
            message(FATAL_ERROR "Invalid GTest fetch arguments")
        endif()
        # For Windows: Prevent overriding the parent project's compiler/linker settings
        set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
        set(BUILD_GMOCK OFF CACHE BOOL "" FORCE)
        set(BUILD_GTEST ON CACHE BOOL "" FORCE)
        option(INSTALL_GMOCK OFF)
        option(INSTALL_GTEST OFF)
        FetchContent_MakeAvailable(googletest)
        message("GoogleTest has been enabled...")
    endif()
endmacro()

macro(addTest)
    if (ENABLE_UNIT_TESTS)
        set(TEST_P_NAME ${PROJECT_NAME}_test)
        file(GLOB_RECURSE TEST_SRC test/*.cpp test/*.c test/*.hpp test/*.h)

        add_executable(${TEST_P_NAME} ${TEST_SRC})

        target_link_libraries(${TEST_P_NAME} PRIVATE ${PROJECT_NAME} gtest_main)
        foreach(arg IN LISTS ARGN)
            target_link_libraries(${TEST_P_NAME} PRIVATE ${arg})
        endforeach()

        enable_testing()
        add_test(NAME ${TEST_P_NAME} COMMAND ${TEST_P_NAME})
    endif()
endmacro()