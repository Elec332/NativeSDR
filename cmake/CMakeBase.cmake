include(CMakeParseArguments)
include(GNUInstallDirs)
include(FetchContent)
find_package(PkgConfig)
if(NOT CMAKE_BASE_INCLUDE)
    set(CMAKE_BASE_INCLUDE ${CMAKE_CURRENT_LIST_FILE})
endif()

function(addProject)
    cmake_parse_arguments(AP "LIB;LIBRARY;SHARED;STATIC;EXECUTABLE;NO_SOURCES" "EXPORT_HEADER_DIR" "" ${ARGN})
    if(NOT (AP_LIB OR AP_LIBRARY OR AP_SHARED OR AP_STATIC OR AP_EXECUTABLE))
        message(FATAL_ERROR "No project type specified!")
    endif()
    if((AP_LIB OR AP_LIBRARY OR AP_SHARED OR AP_STATIC) AND AP_EXECUTABLE)
        message(FATAL_ERROR "Executable with library parameters!")
    endif()
    if(AP_SHARED AND AP_STATIC)
        message(FATAL_ERROR "A library cannot be both SHARED and STATIC!")
    endif()
    if((AP_LIB OR AP_LIBRARY) AND NOT (AP_SHARED OR AP_STATIC))
        message(FATAL_ERROR "Library type not defined!")
    endif()

    if(NOT AP_NO_SOURCES)
        getSources()
    endif()

    if(AP_LIB OR AP_LIBRARY)
        if(AP_SHARED)
            add_library(${PROJECT_NAME} SHARED ${SRC} ${SRC_C})
            if(AP_EXPORT_HEADER_DIR)
                set(AP_EXPORT_HEADER_DIR "${AP_EXPORT_HEADER_DIR}")
            endif()
            if(NOT AP_EXPORT_HEADER_DIR AND EXPORT_HEADER_BASE_DIR)
                set(AP_EXPORT_HEADER_DIR "${EXPORT_HEADER_BASE_DIR}")
            endif()

            if(AP_EXPORT_HEADER_DIR)
                withExportHeaders(FOLDER ${AP_EXPORT_HEADER_DIR})
            else()
                withExportHeaders()
            endif()
            importSharedLibraries()
        else()
            add_library(${PROJECT_NAME} STATIC ${SRC} ${SRC_C})
        endif()
    else()
        add_executable(${PROJECT_NAME} ${SRC} ${SRC_C})
        importSharedLibraries()
    endif()

    if(NOT (${CMAKE_PROJECT_NAME} STREQUAL ${PROJECT_NAME}))
        if(AP_EXECUTABLE)
            add_executable(${CMAKE_PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
        else()
            add_library(${CMAKE_PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
        endif()
    endif()

    addIncludeDirectories()
    processAssets(assets)
endfunction()

macro(getSources)
    file(GLOB_RECURSE SRC src/cpp/*.cpp src/cpp/*.c src/cpp/*.hpp src/cpp/*.h)
    file(GLOB_RECURSE SRC_C src/c/*.c src/c/*.h)
    set_source_files_properties(${SRC} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRC_C} PROPERTIES LANGUAGE C)
endmacro()

macro(addIncludeDirectories)
    target_include_directories(${PROJECT_NAME} PRIVATE src/headers)
    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src/public> $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
endmacro()

macro(processAssets)
    if(DEFINED ARGV0)
        set(ASSET_DIR ${ARGV0})
    endif()
    if(NOT DEFINED ASSET_DIR)
        set(ASSET_DIR assets)
    endif()
    if(EXISTS ${PROJECT_SOURCE_DIR}/assets/)
        file(GLOB files "assets/*.*")
        set(ASSET_OUTPUTS)
        foreach(file ${files})
            cmake_path(GET file FILENAME file_name)
            set(FNDR ${${PROJECT_NAME}_BINARY_DIR}/${ASSET_DIR}/${file_name})
            add_custom_command(OUTPUT ${FNDR} COMMAND ${CMAKE_COMMAND} -E copy_if_different ${file} ${${PROJECT_NAME}_BINARY_DIR}/${ASSET_DIR} MAIN_DEPENDENCY ${file})
            list(APPEND ASSET_OUTPUTS ${FNDR})
            install(FILES ${FNDR} DESTINATION ${ASSET_DIR})
        endforeach()
        add_custom_target(${PROJECT_NAME}_assets ALL DEPENDS ${ASSET_OUTPUTS})
        add_dependencies(${PROJECT_NAME} ${PROJECT_NAME}_assets)
    endif()
endmacro()

function(withExportHeaders)
    cmake_parse_arguments(WEH "" "FOLDER" "" ${ARGN})
    include(GenerateExportHeader)
    set(CMAKE_CURRENT_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/export_h_dir/${WEH_FOLDER})
    generate_export_header(${PROJECT_NAME})

    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/export_h_dir>)
endfunction()

macro(installHeaders)
    if(NOT INSTALL_HEADERS_${PROJECT_NAME})
        if(DEFINED ARGV0)
            set(CMAKE_INSTALL_INCLUDEDIR ${ARGV0})
        elseif(NOT DEFINED CMAKE_INSTALL_INCLUDEDIR)
            set(CMAKE_INSTALL_INCLUDEDIR include)
        endif()
        set(INSTALL_HEADERS_${PROJECT_NAME} true)
        function(installHeaders_late)
            get_target_property(IID_DDD ${PROJECT_NAME} INTERFACE_INCLUDE_DIRECTORIES)
            foreach(file ${IID_DDD})
                install(CODE "
                    set(copy_dir \"$<$<AND:$<NOT:$<STREQUAL:${file},>>,$<NOT:$<STREQUAL:${file},${PROJECT_BINARY_DIR}>>>:${file}/>\")
                    if(NOT \${copy_dir} STREQUAL \"\" AND EXISTS \${copy_dir})
                        file(INSTALL DESTINATION \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}\" TYPE DIRECTORY FILES \"\${copy_dir}\")
                    endif()
                ")
            endforeach()
        endfunction()
        cmake_language(DEFER CALL installHeaders_late)
    endif()
endmacro()

macro(installRuntime)
    cmake_parse_arguments(IRT "DEV" "DESTINATION" "" ${ARGN})
    if(IRT_DESTINATION)
        set(DEST_IRT ${IRT_DESTINATION})
    else()
        set(DEST_IRT /)
    endif()
    if(IRT_DEV)
        installHeaders()
        install(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME} RUNTIME DESTINATION ${DEST_IRT} ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
        if(NOT (${CMAKE_PROJECT_NAME} STREQUAL ${PROJECT_NAME}))
            install(EXPORT ${PROJECT_NAME} NAMESPACE ${CMAKE_PROJECT_NAME}:: FILE ${PROJECT_NAME}Config.cmake DESTINATION cmake)
        else()
            install(EXPORT ${PROJECT_NAME} FILE ${PROJECT_NAME}Config.cmake DESTINATION cmake)
        endif()
    else()
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION ${DEST_IRT})
    endif()

    checkInstallFiles()
    copyMinGWLibs()
endmacro()

function(checkInstallFiles)
    get_directory_property(hasParent PARENT_DIRECTORY)
    if(NOT hasParent)
        function(checkInstallFiles2)
            install(CODE "
                set(MAN_FILE ${CMAKE_CURRENT_BINARY_DIR}/install_manifest.txt)
                if(EXISTS \${MAN_FILE})
                    file(READ \${MAN_FILE} files)
                    string(REGEX REPLACE \"\\n\" \";\" files \"\${files}\")
                elseif()
                    set(files \"\")
                endif()
                set(DELETED_D \"\")
                foreach(file \${files})
                    list(FIND CMAKE_INSTALL_MANIFEST_FILES \${file} D_IX)
                    if(NOT (\${D_IX} GREATER_EQUAL 0))
                        list(APPEND DELETED_D \${file})
                        message(\"Deleting file: \${file}\")
                    endif()
                endforeach()
                if(NOT (\"x\${DELETED_D}x\" STREQUAL \"xx\"))
                    file(REMOVE \${DELETED_D})
                endif()
            ")
        endfunction()
        cmake_language(DEFER CALL delayDefer checkInstallFiles2)
    endif()
endfunction()

macro(createMinGWBaseFile)
    if(NOT MW_BASE_FILE)
        set(MW_BASE_FILE ${CMAKE_BINARY_DIR}/MinGWBinCopy.cmake)
        set(EXCL "")
        foreach(lib ${CMAKE_CXX_IMPLICIT_LINK_LIBRARIES})
            string(REPLACE "+" "\\\\+" lib ${lib}) #Escape for regex
            list(APPEND EXCL .*${lib})
        endforeach()
        set(BINZ "")
        foreach(lib ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES})
            list(APPEND BINZ ${lib}/../bin)
        endforeach()
        file(WRITE ${MW_BASE_FILE} "
                file(GET_RUNTIME_DEPENDENCIES
                    EXECUTABLES \${TARGET_FILE_E}
                    RESOLVED_DEPENDENCIES_VAR RESOLVED_DEPS
                    UNRESOLVED_DEPENDENCIES_VAR UNRESOLVED_DEPS
                    POST_EXCLUDE_REGEXES \".*system32/.*\\\\.dll\"
                    DIRECTORIES ${BINZ}
                )
                set(EXCL \"\")
                foreach(dep \${RESOLVED_DEPS})
                    foreach(excl ${EXCL})
                        if(\"\${dep}\" MATCHES \"\${excl}\")
                            list(APPEND EXCL \${dep})
                        endif()
                    endforeach()
                endforeach()
                list(REMOVE_DUPLICATES EXCL)
                foreach(excl \${EXCL})
                    file(INSTALL
                        DESTINATION \"\${DEST_FOLDER}\"
                        FOLLOW_SYMLINK_CHAIN
                        FILES \"\${excl}\"
                    )
                endforeach()
            ")
        unset(EXCL)
        unset(BINZ)
    endif()
endmacro()

macro(copyMinGWLibs)
    if(WIN32 AND NOT MSVC) # Yes you, MinGW....
        createMinGWBaseFile()
        install(CODE "
            set(TARGET_FILE_E $<TARGET_FILE:${PROJECT_NAME}>)
            set(DEST_FOLDER ${CMAKE_INSTALL_PREFIX}/${DEST})
            include(\"${MW_BASE_FILE}\")
        ")
    endif()
endmacro()

macro(importSharedLibraries)
    if(NOT (${CMAKE_VERSION} VERSION_LESS "3.20") AND WIN32)
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $<IF:$<STREQUAL:$<TARGET_RUNTIME_DLLS:${PROJECT_NAME}>,>,$<TARGET_FILE:${PROJECT_NAME}>,$<TARGET_RUNTIME_DLLS:${PROJECT_NAME}>> $<TARGET_FILE_DIR:${PROJECT_NAME}> COMMAND_EXPAND_LISTS)
        if(NOT MSVC)
            createMinGWBaseFile()
            add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -DDEST_FOLDER="$<TARGET_FILE_DIR:${PROJECT_NAME}>" -DTARGET_FILE_E=$<TARGET_FILE:${PROJECT_NAME}> -P ${MW_BASE_FILE} COMMAND_EXPAND_LISTS)
        endif()
    endif()
endmacro()

macro(setCentralOutput)
    set_target_properties(${PROJECT_NAME} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
endmacro()

macro(forceX64)
    if(IGNORE_TARGET_PLATFORM)
        message(STATUS "Disabling target platform check")
    elseif(MSVC AND NOT (${CMAKE_GENERATOR} STREQUAL "Ninja"))
        set(CMAKE_GENERATOR_PLATFORM x64)
    elseif(NOT (${CMAKE_SIZEOF_VOID_P} EQUAL 8))
        message(FATAL_ERROR "Target is not 64 bit.\n This cannot be forced from CMakeLists, so please make sure you are using a x64 toolchain.")
    endif()
endmacro()

function(makeRootCMakeConfig)
    cmake_parse_arguments(MRCC "" "DESTINATION" "FILES" ${ARGN})
    string(TOUPPER ${PROJECT_NAME} PROJ_NAME_UPPER)
    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/Config.cmake.in "
\@PACKAGE_INIT@
set(${PROJ_NAME_UPPER}_INSTALL_DIR \${PACKAGE_PREFIX_DIR})
file(GLOB CONFIG_FILES \"\${CMAKE_CURRENT_LIST_DIR}/*Config.cmake\")
foreach(f \${CONFIG_FILES})
    if(NOT (\${CMAKE_CURRENT_LIST_FILE} STREQUAL \${f}))
        include(\${f})
    endif()
endforeach()
            ")
    include(CMakePackageConfigHelpers)
    if(MRCC_DESTINATION)
        set(DEST_F ${MRCC_DESTINATION})
    else()
        set(DEST_F cmake)
    endif()

    foreach(file ${MRCC_FILES})
        cmake_path(GET file FILENAME file_name)
        configure_file(${file} ${CMAKE_BINARY_DIR}/${file_name} @ONLY)
        install(FILES ${CMAKE_BINARY_DIR}/${file_name} DESTINATION ${DEST_F})
    endforeach()

    configure_package_config_file(${CMAKE_CURRENT_BINARY_DIR}/Config.cmake.in "${CMAKE_BINARY_DIR}/${PROJECT_NAME}Config.cmake" INSTALL_DESTINATION ${DEST_F} NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO)
    install(FILES ${CMAKE_BINARY_DIR}/${PROJECT_NAME}Config.cmake DESTINATION ${DEST_F})
endfunction()

#####################################################
## Libraries
#####################################################

function(useLibraries name)
    if(${name} STREQUAL NAMES)
        set(ARG_START ARGV)
    else()
        set(ARG_START ARGN)
    endif()
    cmake_parse_arguments(ULB "PUBLIC;PRIVATE;STATIC_HEADERS" "INSTALL;WIN_INSTALL;HEADER_ROOT_DIR" "NAMES;HEADER_INCLUDE_DIRS;HEADER_INCLUDE_FILES" ${${ARG_START}})
    if(NOT (${name} STREQUAL NAMES) AND ULB_NAMES)
        message(FATAL_ERROR "single and multi-target defined!")
    elseif(NOT ULB_NAMES)
        list(APPEND ULB_NAMES ${name})
    endif()

    foreach(tgt ${ULB_NAMES})
        if(NOT (TARGET ${tgt}))
            message(FATAL_ERROR "${tgt} is not a target!")
            return()
        endif()
    endforeach()
    if(ULB_PUBLIC AND ULB_PRIVATE)
        message(FATAL_ERROR "Dependency ${name} cannot be public AND private!")
        return()
    endif()
    if((NOT ULB_PUBLIC) AND (NOT ULB_PRIVATE))
        message(FATAL_ERROR "Dependency ${name} has no visibility defined!")
        return()
    endif()
    if(ULB_INSTALL AND ULB_WIN_INSTALL)
        message(FATAL_ERROR "Install location for ${name} defined twice!")
        return()
    endif()

    if(ULB_WIN_INSTALL)
        set(ULB_INSTALL ${ULB_WIN_INSTALL})
    endif()

    foreach(target ${ULB_NAMES})
        get_target_property(target_type ${target} TYPE)
        if(ULB_PUBLIC)
            if(${target_type} STREQUAL STATIC_LIBRARY AND ULB_STATIC_HEADERS)
                target_link_libraries(${PROJECT_NAME} PRIVATE ${target})
                get_target_property(target_includes ${target} INTERFACE_INCLUDE_DIRECTORIES)
                foreach(target_include ${target_includes})
                    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${target_include}>)
                endforeach()
            else()
                target_link_libraries(${PROJECT_NAME} PUBLIC ${target})
            endif()
        else()
            target_link_libraries(${PROJECT_NAME} PRIVATE ${target})
        endif()

        if((ULB_WIN_INSTALL AND WIN32) OR (NOT ULB_WIN_INSTALL AND ULB_INSTALL))
            installUsedLibrary()
        endif()
    endforeach()

endfunction()

macro(installUsedLibrary)
    install(IMPORTED_RUNTIME_ARTIFACTS ${target} RUNTIME DESTINATION ${ULB_INSTALL})
    if(ULB_HEADER_ROOT_DIR OR ULB_HEADER_INCLUDE_DIRS OR ULB_HEADER_INCLUDE_FILES)
        if(WIN32)
            getConfigurableProperty(LIB ${target} IMPORTED_IMPLIB)
            install(FILES ${LIB} DESTINATION ${CMAKE_INSTALL_LIBDIR})
            cmake_path(GET LIB FILENAME file_name)
            set(IMPLIB_INSTALL_LINE "IMPORTED_IMPLIB_RELEASE \"\${PACK_PREF_DIR}/${CMAKE_INSTALL_LIBDIR}/${file_name}\"")
        endif()
        getConfigurableProperty(H_ROOT ${target} INTERFACE_INCLUDE_DIRECTORIES)
        set(H_ROOT ${H_ROOT}/${ULB_HEADER_ROOT_DIR})
        foreach(H_DIR ${ULB_HEADER_INCLUDE_DIRS})
            install(DIRECTORY ${H_ROOT}/${H_DIR}/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${H_DIR})
        endforeach()
        foreach(H_FILE ${ULB_HEADER_INCLUDE_FILES})
            find_file(H_FILER ${H_FILE} NO_CACHE REQUIRED PATHS ${H_ROOT})
            install(FILES ${H_FILER} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${H_FILE})
        endforeach()

        if(NOT (${target_type} STREQUAL SHARED_LIBRARY))
            message(FATAL_ERROR "Cannot install non-\"Shared Library\" target")
        endif()
        if(NOT ${target}_CMAKE_FILE)
            string(REPLACE "::" "_" target_name ${target})
            set(${target}_CMAKE_FILE ${CMAKE_BINARY_DIR}/${target_name}Config.cmake)
            set(${target}_CMAKE_FILE ${${target}_CMAKE_FILE} PARENT_SCOPE)
            getConfigurableProperty(ILBIN ${target} IMPORTED_LOCATION)
            cmake_path(GET ILBIN FILENAME file_name)
            file(WRITE ${${target}_CMAKE_FILE} "
                if(TARGET ${target})
                    return()
                endif()
                add_library(${target} SHARED IMPORTED)
                get_filename_component(PACK_PREF_DIR \"\${CMAKE_CURRENT_LIST_DIR}/../\" ABSOLUTE)
                set_property(TARGET ${target} APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
                set_target_properties(${target} PROPERTIES
                    INTERFACE_INCLUDE_DIRECTORIES \"\${PACK_PREF_DIR}/${CMAKE_INSTALL_INCLUDEDIR}\"
                    ${IMPLIB_INSTALL_LINE}
                    IMPORTED_LOCATION_RELEASE \"\${PACK_PREF_DIR}/${ULB_INSTALL}/${file_name}\"
                )
            ")
        endif()
        install(FILES ${${target}_CMAKE_FILE} DESTINATION cmake)
    endif()
endmacro()

function(useHeaderLibrary name)
    cmake_parse_arguments(UHLB "PRIVATE" "" "" ${ARGN})
    if(UHLB_PRIVATE)
        target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    else()
        target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/libs/${name}/include>)
    endif()
endfunction()

function(includeDirectory folder)
    cmake_parse_arguments(ID "PUBLIC;PRIVATE" "" "" ${ARGN})
    if(ID_PUBLIC AND ID_PRIVATE)
        message(FATAL_ERROR "Include directory ${folder} cannot be public AND private!")
        return()
    endif()
    if((NOT ID_PUBLIC) AND (NOT ID_PRIVATE))
        message(FATAL_ERROR "Include directory ${folder} has no visibility defined!")
        return()
    endif()

    if(ID_PUBLIC)
        target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${folder}>)
    else()
        target_include_directories(${PROJECT_NAME} PRIVATE ${folder})
    endif()
endfunction()

function(useSourceLibrary name)
    cmake_parse_arguments(UHLB "CLOSED" "" "" ${ARGN})
    set(NAME_BASE ${PROJECT_SOURCE_DIR}/libs/${name})
    file(GLOB_RECURSE SRCD ${NAME_BASE}/cpp/*.cpp ${NAME_BASE}/cpp/*.c)
    file(GLOB_RECURSE SRCD_C ${NAME_BASE}/c/*.c)
    target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/headers)
    if(EXISTS ${NAME_BASE}/public)
        target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${NAME_BASE}/public>)
    endif()
    if(NOT UHLB_CLOSED)
        target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/cpp)
        target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/c)
    endif()
    set_source_files_properties(${SRCD} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRCD_C} PROPERTIES LANGUAGE C)
    target_sources(${PROJECT_NAME} PRIVATE ${SRCD})
    target_sources(${PROJECT_NAME} PRIVATE ${SRCD_C})
endfunction()

function(findLibrary name)
    cmake_parse_arguments(CSL "REQUIRED;QUIET" "DLL;LIB;DLLD;LIBD;FILE;FILED;NAME;FIND_HEADER;HEADER_DIR" "DEPENDENCIES;COMPONENTS" ${ARGN})

    testPackage(${name})
    if(${${name}__FOUND})
        find_package(${name} REQUIRED ${CSL_COMPONENTS})
        message("${name} FOUND")
        return()
    endif()

    if(CSL_NAME)
        set(t_name ${CSL_NAME})
    else()
        set(t_name ${name})
    endif()
    if(CSL_COMPONENTS)
        list(LENGTH CSL_COMPONENTS COMPONENTS_LEN)
        if(${COMPONENTS_LEN} GREATER 1)
            message(FATAL_ERROR "Cannot sub-search for multiple modules!")
        elseif(${COMPONENTS_LEN} EQUAL 1)
            set(t_name ${t_name}::${CSL_COMPONENTS})
        endif()
    endif()

    if(WIN32)
        find_library(UIDL uuid HINTS ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES})
    endif()

    set(BINZ "")
    foreach(lib ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES})
        list(APPEND BINZ ${lib}/../bin)
    endforeach()

    if(CSL_FIND_HEADER)
        findWithHeaderInternal()
        if(TARGET ${t_name})
            return()
        endif()
    endif()

    if(PKG_CONFIG_FOUND AND ${PKG_CONFIG_FOUND})
        pkg_search_module(${name} ${name})
        if(${name}_MODULE_NAME)
            message("${name} NOT FOUND -> PKG")
            if(CSL_GLOBAL)
                add_library(${t_name} SHARED IMPORTED GLOBAL)
            else()
                add_library(${t_name} SHARED IMPORTED)
            endif()

            if(${name}_INCLUDE_DIRS)
                set_property(TARGET ${t_name} PROPERTY INTERFACE_INCLUDE_DIRECTORIES "${${name}_INCLUDE_DIRS}")
            endif()
            if(${name}_LINK_LIBRARIES)
                set_property(TARGET ${t_name} PROPERTY INTERFACE_LINK_LIBRARIES "${${name}_LINK_LIBRARIES}")
            endif()
            if(${name}_LDFLAGS_OTHER)
                set_property(TARGET ${t_name} PROPERTY INTERFACE_LINK_OPTIONS "${${name}_LDFLAGS_OTHER}")
            endif()
            if(${name}_CFLAGS_OTHER)
                set_property(TARGET ${t_name} PROPERTY INTERFACE_COMPILE_OPTIONS "${${name}_CFLAGS_OTHER}")
            endif()

            checkImportedDLLInternal()
            return()
        endif()
    endif()

    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        if(EXISTS ${csl_root})
            message("${t_name} NOT FOUND -> Hardsearch")
            if(CSL_GLOBAL)
                add_library(${t_name} SHARED IMPORTED GLOBAL)
            else()
                add_library(${t_name} SHARED IMPORTED)
            endif()

            if(CSL_DEPENDENCIES)
                set_target_properties(${t_name} PROPERTIES INTERFACE_LINK_LIBRARIES ${CSL_DEPENDENCIES})
            endif()

            if(EXISTS "${csl_root}/include")
                set_target_properties(${t_name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")
            endif()

            if(CSL_DLL)
                set(CSL_DLL_FILE ${CSL_DLL}.dll)
            else()
                if(CSL_FILE)
                    set(CSL_DLL_FILE ${CSL_FILE}.dll)
                else()
                    set(CSL_DLL_FILE ${name}.dll)
                endif()
            endif()
            set_target_properties(${t_name} PROPERTIES IMPORTED_LOCATION "${csl_root}/bin/${CSL_DLL_FILE}")

            if(CSL_LIB)
                set(CSL_LIB_FILE ${CSL_LIB}.lib)
            else()
                if(CSL_FILE)
                    set(CSL_LIB_FILE ${CSL_FILE}.lib)
                else()
                    set(CSL_LIB_FILE ${name}.lib)
                endif()
            endif()
            if(EXISTS "${csl_root}/lib/${CSL_LIB_FILE}")
                set_target_properties(${t_name} PROPERTIES IMPORTED_IMPLIB "${csl_root}/lib/${CSL_LIB_FILE}")
            else()
                set_target_properties(${t_name} PROPERTIES IMPORTED_IMPLIB ${UIDL}) # Jokes on you
                #set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB NOTFOUND)
            endif()

            if(CSL_DLLD)
                set_target_properties(${t_name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_DLLD}.dll")
            elseif(CSL_FILED)
                set_target_properties(${t_name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_FILED}.dll")
            endif()
            if(CSL_LIBD)
                set_target_properties(${t_name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
            elseif(CSL_FILED)
                set_target_properties(${t_name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_FILED}.lib")
            endif()
            return()
        endif()
    endif()

    if(CSL_REQUIRED)
        message(FATAL_ERROR "Failed to locate library: ${name}")
    elseif(NOT CSL_QUIET)
        message(WARNING "Failed to locate library: ${name}")
    endif()

endfunction()

macro(findWithHeaderInternal)
    find_path(${name}_INCLUDE_DIR ${CSL_FIND_HEADER} NO_CACHE)
    set(${name}_INCLUDE_DIR ${${name}_INCLUDE_DIR}/${HEADER_DIR})
    if(CSL_FILE)
        find_library(${name}_LIBRARY ${CSL_FILE} NO_CACHE)
        if(${${name}_LIBRARY} STREQUAL ${name}_LIBRARY-NOTFOUND)
            find_library(${name}_LIBRARY ${name} NO_CACHE)
        endif()
    else()
        find_library(${name}_LIBRARY ${name} NO_CACHE)
    endif()

    if(EXISTS ${${name}_INCLUDE_DIR} AND EXISTS ${${name}_LIBRARY})
        get_filename_component(${name}_LIB_FOLDER ${${name}_LIBRARY} DIRECTORY)
        list(APPEND BINZ ${${name}_LIB_FOLDER}/../bin)

        if(CSL_GLOBAL)
            add_library(${t_name} SHARED IMPORTED GLOBAL)
        else()
            add_library(${t_name} SHARED IMPORTED)
        endif()

        set_property(TARGET ${t_name} PROPERTY INTERFACE_INCLUDE_DIRECTORIES "${${name}_INCLUDE_DIR}")
        set_property(TARGET ${t_name} PROPERTY INTERFACE_LINK_LIBRARIES "${${name}_LIBRARY}")

        checkImportedDLLInternal()
        message("${t_name} FOUND /W HEADERS")
    endif()

endmacro()

macro(checkImportedDLLInternal)
    if(WIN32)
        set_property(TARGET ${t_name} PROPERTY IMPORTED_IMPLIB ${UIDL}) # Jokes on you
        find_file(TESTVALPR_${name} NAMES "${CSL_DLL}.dll" "${CSL_FILE}.dll" "${name}.dll" "lib${CSL_DLL}.dll" "lib${CSL_FILE}.dll" "lib${name}.dll" PATHS ${BINZ} REQUIRED NO_CACHE)
        set_property(TARGET ${t_name} PROPERTY IMPORTED_LOCATION "${TESTVALPR_${name}}")
    endif()
endmacro()

function(getRemoteLibrary name)
    cmake_parse_arguments(GRL "NO_BUILD" "GIT_REPO;GIT_TAG;FILE;FIND" "BUILD_ARGS" ${ARGN})
    if(GRL_FILE)
        FetchContent_Declare(${name}_GIT URL file://${PROJECT_SOURCE_DIR}/${GRL_FILE})
    else()
        if(NOT GRL_GIT_REPO)
            message(FATAL_ERROR "No repository defined for: ${name}")
        endif()
        if(NOT GRL_GIT_TAG)
            set(GRL_GIT_TAG master)
        endif()
        FetchContent_Declare(${name}_GIT GIT_REPOSITORY ${GRL_GIT_REPO} GIT_TAG ${GRL_GIT_TAG})
    endif()
    if(NOT ${name}_GIT_POPULATED OR NOT ${${name}_GIT_POPULATED})
        string(TOLOWER ${name}_GIT name_lower)
        FetchContent_Populate(${name}_GIT)
        if(NOT ${${name}_GIT_POPULATED})
            message(FATAL_ERROR "Failed to populate remote dependency ${name}")
        endif()
        set(${name}_GIT_POPULATED TRUE CACHE BOOL "" FORCE)
        set(${name}_SOURCE_DIR ${${name_lower}_SOURCE_DIR} CACHE PATH "" FORCE)
        set(${name}_BINARY_DIR ${${name_lower}_BINARY_DIR} CACHE PATH "" FORCE)
        if(GRL_NO_BUILD)
            return()
        endif()
        set(CMAKE_DEP_ARGS "")
        list(APPEND CMAKE_DEP_ARGS -Wno-dev)
        if(GRL_BUILD_ARGS)
            foreach(arg ${GRL_BUILD_ARGS})
                list(APPEND CMAKE_DEP_ARGS ${arg})
            endforeach()
        endif()
        list(APPEND CMAKE_DEP_ARGS -DCMAKE_INSTALL_PREFIX=${${name}_BINARY_DIR}/installdir)
        if(CMAKE_GENERATOR)
            list(APPEND CMAKE_DEP_ARGS -DCMAKE_GENERATOR=${CMAKE_GENERATOR})
        endif()
        if(CMAKE_MAKE_PROGRAM)
            list(APPEND CMAKE_DEP_ARGS -DCMAKE_MAKE_PROGRAM=${CMAKE_MAKE_PROGRAM})
        endif()
        execute_process(COMMAND ${CMAKE_COMMAND} ${${name}_SOURCE_DIR} ${CMAKE_DEP_ARGS} WORKING_DIRECTORY ${${name}_BINARY_DIR})
        execute_process(COMMAND ${CMAKE_COMMAND} --build . --config ${CMAKE_BUILD_TYPE} --target install WORKING_DIRECTORY ${${name}_BINARY_DIR})
    endif()
    if(NOT GRL_NO_BUILD)
        list(APPEND CMAKE_PREFIX_PATH ${${name}_BINARY_DIR}/installdir)
        set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} PARENT_SCOPE)
    endif()
    if(GRL_FIND)
        find_package(${GRL_FIND})
    endif()
endfunction()

function(useRemoteSource name new_name)
    cmake_parse_arguments(URS "CLOSED" "PUBLIC_HEADER_DIR;ROOT" "PUBLIC_HEADER_FILES;PRIVATE_HEADER_FILES;SOURCE_FILES;REPLACE" ${ARGN})
    if(NOT ${name}_SOURCE_DIR)
        message(FATAL_ERROR "${name} is not a remote source!")
    endif()

    set(SOURCE_ROOT ${${name}_SOURCE_DIR})
    if(URS_ROOT)
        set(SOURCE_ROOT ${SOURCE_ROOT}/${URS_ROOT})
    endif()

    if(NOT URC_ALL_FILES_LIST)
        delayDefer(replaceRemoteSourceFiles)
    endif()
    get_filename_component(ROOT_FOLDER "${${name}_SOURCE_DIR}/../${new_name}_src_dep" ABSOLUTE)

    foreach(file ${URS_PUBLIC_HEADER_FILES})
        subInstallRemoteSource(include /${URS_PUBLIC_HEADER_DIR})
    endforeach()
    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${ROOT_FOLDER}/include>)

    foreach(file ${URS_PRIVATE_HEADER_FILES})
        subInstallRemoteSource(headers /)
    endforeach()
    target_include_directories(${PROJECT_NAME} PRIVATE $<BUILD_INTERFACE:${ROOT_FOLDER}/headers>)

    foreach(file ${URS_SOURCE_FILES})
        subInstallRemoteSource(src /)
    endforeach()
    file(GLOB_RECURSE SRC ${ROOT_FOLDER}/src/*.cpp ${ROOT_FOLDER}/src/*.c)
    target_sources(${PROJECT_NAME} PRIVATE ${SRC})
    if(NOT URS_CLOSED)
        target_include_directories(${PROJECT_NAME} PRIVATE ${ROOT_FOLDER}/src)
    endif()
    foreach(repl ${URS_REPLACE})
        list(APPEND URC_REPLACE_FILES_LIST "${repl}")
    endforeach()

    set(URC_ALL_FILES_LIST ${URC_ALL_FILES_LIST} PARENT_SCOPE)
    set(URC_REPLACE_FILES_LIST ${URC_REPLACE_FILES_LIST} PARENT_SCOPE)
endfunction()

macro(subInstallRemoteSourceCopy subdir subdir2 file)
    if(NOT (${file} IN_LIST ALL_FILES))
        file(COPY ${file} DESTINATION ${DEST})
        get_filename_component(FNAME "${file}" NAME)
        list(APPEND URC_ALL_FILES_LIST "${DEST}/${FNAME}")
        file(RELATIVE_PATH FNAME2 "${ROOT_FOLDER}/${subdir}" "${DEST}/${FNAME}")
        file(RELATIVE_PATH FNAME "${ROOT_FOLDER}/${subdir}${subdir2}" "${DEST}/${FNAME}")
        if(NOT (${FNAME} STREQUAL ${FNAME2}))
            list(APPEND URC_REPLACE_FILES_LIST "${FNAME}|${FNAME2}")
        endif()
        list(APPEND ALL_FILES "${file}")
    endif()
endmacro()

macro(subInstallRemoteSource subdir subdir2)
    get_filename_component(DEST "${ROOT_FOLDER}/${subdir}${subdir2}/${file}/../" ABSOLUTE)
    if(EXISTS ${SOURCE_ROOT}/${file})
        subInstallRemoteSourceCopy("${subdir}" "${subdir2}" ${SOURCE_ROOT}/${file})
    else()
        file(GLOB FLS ${SOURCE_ROOT}/${file})
        foreach(fls2 ${FLS})
            subInstallRemoteSourceCopy("${subdir}" "${subdir2}" ${fls2})
        endforeach()
    endif()
endmacro()

function(replaceRemoteSourceFiles)
    foreach(file ${URC_ALL_FILES_LIST})
        file(READ ${file} filedata)
        foreach(replaces ${URC_REPLACE_FILES_LIST})
            string(REPLACE "|" ";" replaces "${replaces}")
            list(POP_FRONT replaces now new)
#            message("repl: ${now} -> ${new}")
            string(REPLACE "${now}" "${new}" filedata "${filedata}")
        endforeach()
        file(WRITE ${file} "${filedata}")
    endforeach()
endfunction()

#####################################################
## Python bullshit
#####################################################

macro(findPython)
    find_package(Python3 COMPONENTS Interpreter Development REQUIRED)
    if(Python3_EXECUTABLE)
        set(PYTHON_EXECUTABLE ${Python3_EXECUTABLE})
        set(PYTHON3_EXECUTABLE ${Python3_EXECUTABLE})
    endif()
endmacro()

macro(checkPythonModule description package cmd result_var)
    cmake_parse_arguments(CPM "QUIET" "" "" ${ARGN})
    if(NOT CPM_QUIET)
        message(STATUS "Python checking for ${description}")
    endif()
    execute_process(
            COMMAND ${PYTHON_EXECUTABLE} -c "
#########################################
try: import ${package}
except:
    try: ${package}
    except: exit(-1)
try: assert ${cmd}
except: exit(-1)
#########################################"
            RESULT_VARIABLE ${result_var}
    )
    if(${result_var} EQUAL 0)
        if(NOT CPM_QUIET)
            message(STATUS "Python checking for ${description} - found")
        endif()
        set(${result_var} TRUE)
    else()
        if(NOT CPM_QUIET)
            message(STATUS "Python checking for ${description} - not found")
        endif()
        set(${result_var} FALSE)
    endif()
endmacro()

function(ensurePythonModule description package cmd)
    checkPythonModule(${description} ${package} ${cmd} ${package}_FOUND QUIET)
    if(${${package}_FOUND})
        message(STATUS "Python package ${description} found")
        return()
    endif()
    message("${PYTHON_EXECUTABLE} -m pip install \"${description}\"")
    execute_process(COMMAND ${PYTHON_EXECUTABLE} -m pip install "${description}")
    checkPythonModule(${description} ${package} ${cmd} ${package}_FOUND QUIET)
    if(NOT ${${package}_FOUND})
        message(FATAL_ERROR "Failed to ensure presence of python package ${description}")
    endif()
    message(STATUS "Python package ${description} found")
endfunction()

#####################################################
## GTest
#####################################################

macro(fetchGTest)
    if(NOT DEFINED ENABLE_UNIT_TESTS)
        option(ENABLE_UNIT_TESTS "Enable unit tests" ON)
    endif()
    message(STATUS "Enable testing: ${ENABLE_UNIT_TESTS}")
    if(${ENABLE_UNIT_TESTS})
        cmake_parse_arguments(AGT "" "FILE;VERSION" "" ${ARGN})
        if(AGT_VERSION)
            FetchContent_Declare(googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG ${AGT_VERSION})
        elseif(AGT_FILE)
            FetchContent_Declare(googletest URL file://${PROJECT_SOURCE_DIR}/${AGT_FILE})
        else()
            message(FATAL_ERROR "Invalid GTest fetch arguments")
        endif()
        # For Windows: Prevent overriding the parent project's compiler/linker settings
        set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
        set(BUILD_GMOCK OFF CACHE BOOL "" FORCE)
        set(BUILD_GTEST ON CACHE BOOL "" FORCE)
        option(INSTALL_GMOCK OFF)
        option(INSTALL_GTEST OFF)
        FetchContent_MakeAvailable(googletest)
        message(STATUS "GoogleTest has been enabled")
    endif()
endmacro()

macro(addTest)
    if(ENABLE_UNIT_TESTS)
        set(TEST_P_NAME ${PROJECT_NAME}_test)
        file(GLOB_RECURSE TEST_SRC test/*.cpp test/*.c test/*.hpp test/*.h)

        add_executable(${TEST_P_NAME} ${TEST_SRC})

        target_link_libraries(${TEST_P_NAME} PRIVATE ${PROJECT_NAME} gtest_main)
        foreach(arg IN LISTS ARGN)
            target_link_libraries(${TEST_P_NAME} PRIVATE ${arg})
        endforeach()

        enable_testing()
        add_test(NAME ${TEST_P_NAME} COMMAND ${TEST_P_NAME})
    endif()
endmacro()

#####################################################
## Misc utility functions
#####################################################

function(delayDefer func)
    cmake_language(DEFER CALL ${func})
endfunction()

function(testPackage name)
    find_package(${name} CONFIG QUIET)
    if(${${name}_FOUND})
        set(${name}__FOUND TRUE PARENT_SCOPE)
    else()
        set(${name}__FOUND FALSE PARENT_SCOPE)
    endif()
endfunction()

function(getConfigurableProperty out_name dep_name prop_name)
    get_target_property(TPROPS ${dep_name} IMPORTED_CONFIGURATIONS)
    if(NOT ("${TPROPS}" STREQUAL TPROPS-NOTFOUND))
        string(TOLOWER ${CMAKE_BUILD_TYPE} cbt)
        foreach(cfg ${TPROPS})
            string(TOLOWER ${cfg} cfgl)
            if(${cfgl} STREQUAL ${cbt})
                set(ICTY ${cfg})
            endif()
        endforeach()
        if(NOT ICTY)
            foreach(cfg ${TPROPS})
                string(TOLOWER ${cfg} cfgl)
                if(${cfgl} STREQUAL release)
                    set(ICTY ${cfg})
                endif()
            endforeach()
        endif()
        if(NOT ICTY)
            message(FATAL_ERROR "No valid build-types in dependency: ${name}")
        endif()
        get_target_property(${out_name} ${dep_name} ${prop_name}_${ICTY})
        if(NOT (${${out_name}} STREQUAL ${out_name}-NOTFOUND))
            set(${out_name} ${${out_name}} PARENT_SCOPE)
            return()
        endif()
    endif()
    get_target_property(${out_name} ${dep_name} ${prop_name})
    if(${${out_name}} STREQUAL ${out_name}-NOTFOUND)
        message(FATAL_ERROR "Failed to find property ${prop_name} on: ${dep_name}")
    endif()
    set(${out_name} ${${out_name}} PARENT_SCOPE)
endfunction()