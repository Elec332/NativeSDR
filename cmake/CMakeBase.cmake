include(CMakeParseArguments)
if(NOT MSVC)
    find_package(PkgConfig REQUIRED)
endif()
if(NOT CMAKE_BASE_INCLUDE)
    set(CMAKE_BASE_INCLUDE ${CMAKE_CURRENT_LIST_FILE})
endif()

function(delayDefer func)
    cmake_language(DEFER CALL ${func})
endfunction()

function(testPackage name)
    find_package(${name} CONFIG QUIET)
    if(${${name}_FOUND})
        set(${name}__FOUND TRUE PARENT_SCOPE)
    else()
        set(${name}__FOUND FALSE PARENT_SCOPE)
    endif()
endfunction()

function(addProject type)
    getSources()

    #Lib type mapper
    if((${type} STREQUAL LIB) OR (${type} STREQUAL LIBRARY))
        if((DEFINED ARGV1) AND ((${ARGV1} STREQUAL SHARED) OR (${ARGV1} STREQUAL STATIC)))
            set(type ${ARGV1})
        else()
            message(FATAL_ERROR "No/invalid lib type defined")
        endif()
    endif()

    #Lib or executable
    if((${type} STREQUAL SHAREDLIB) OR (${type} STREQUAL SHARED))
        add_library(${PROJECT_NAME} SHARED ${SRC} ${SRC_C})
        withExportHeaders()
        importSharedLibraries()
    elseif((${type} STREQUAL STATICLIB) OR (${type} STREQUAL STATIC))
        add_library(${PROJECT_NAME} STATIC ${SRC} ${SRC_C})
    elseif(${type} STREQUAL EXEC)
        add_executable(${PROJECT_NAME} ${SRC} ${SRC_C})
        importSharedLibraries()
    else()
        message(FATAL_ERROR "Invalid project type: ${type}")
    endif()

    if(NOT (${CMAKE_PROJECT_NAME} STREQUAL ${PROJECT_NAME}))
        if(${type} STREQUAL EXEC)
            add_executable(${CMAKE_PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
        else()
            add_library(${CMAKE_PROJECT_NAME}::${PROJECT_NAME} ALIAS ${PROJECT_NAME})
        endif()
    endif()

    addIncludeDirectories()
    processAssets(assets)
endfunction()

macro(getSources)
    file(GLOB_RECURSE SRC src/cpp/*.cpp src/cpp/*.c src/cpp/*.hpp src/cpp/*.h)
    file(GLOB_RECURSE SRC_C src/c/*.c src/c/*.h)
    set_source_files_properties(${SRC} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRC_C} PROPERTIES LANGUAGE C)
endmacro()

macro(addIncludeDirectories)
    target_include_directories(${PROJECT_NAME} PRIVATE src/headers)
    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src/public> $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
endmacro()

macro(processAssets)
    if(DEFINED ARGV0)
        set(ASSET_DIR ${ARGV0})
    endif()
    if(NOT DEFINED ASSET_DIR)
        set(ASSET_DIR assets)
    endif()
    if(EXISTS ${PROJECT_SOURCE_DIR}/assets/)
        file(GLOB files "assets/*.*")
        set(ASSET_OUTPUTS)
        foreach(file ${files})
            cmake_path(GET file FILENAME file_name)
            set(FNDR ${${PROJECT_NAME}_BINARY_DIR}/${ASSET_DIR}/${file_name})
            add_custom_command(OUTPUT ${FNDR} COMMAND ${CMAKE_COMMAND} -E copy_if_different ${file} ${${PROJECT_NAME}_BINARY_DIR}/${ASSET_DIR} MAIN_DEPENDENCY ${file})
            list(APPEND ASSET_OUTPUTS ${FNDR})
            install(FILES ${FNDR} DESTINATION ${ASSET_DIR})
        endforeach()
        add_custom_target(${PROJECT_NAME}_assets ALL DEPENDS ${ASSET_OUTPUTS})
        add_dependencies(${PROJECT_NAME} ${PROJECT_NAME}_assets)
    endif()
endmacro()

macro(withExportHeaders)
    function(exportHeaders_install)
        if(INSTALL_HEADERS_${PROJECT_NAME})
            string(TOLOWER ${PROJECT_NAME} EHL_LOWER)
            install(FILES ${PROJECT_BINARY_DIR}/${EHL_LOWER}_export.h TYPE INCLUDE)
        endif()
    endfunction()
    include(GenerateExportHeader)
    generate_export_header(${PROJECT_NAME})

    target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}>)
    cmake_language(DEFER CALL exportHeaders_install)
endmacro()

macro(installHeaders)
    if(NOT INSTALL_HEADERS_${PROJECT_NAME})
        if(DEFINED ARGV0)
            set(CMAKE_INSTALL_INCLUDEDIR ${ARGV0})
        elseif(NOT DEFINED CMAKE_INSTALL_INCLUDEDIR)
            set(CMAKE_INSTALL_INCLUDEDIR include)
        endif()
        set(INSTALL_HEADERS_${PROJECT_NAME} true)
        function(installHeaders_late)
            get_target_property(IID_DDD ${PROJECT_NAME} INTERFACE_INCLUDE_DIRECTORIES)
            foreach(file ${IID_DDD})
                install(CODE "
                    set(copy_dir \"$<$<AND:$<NOT:$<STREQUAL:${file},>>,$<NOT:$<STREQUAL:${file},${PROJECT_BINARY_DIR}>>>:${file}/>\")
                    if(NOT \${copy_dir} STREQUAL \"\" AND EXISTS \${copy_dir})
                        file(INSTALL DESTINATION \"\${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}\" TYPE DIRECTORY FILES \"\${copy_dir}\")
                    endif()
                ")
            endforeach()
        endfunction()
        cmake_language(DEFER CALL installHeaders_late)
    endif()
endmacro()

macro(installRuntime)
    cmake_parse_arguments(IRT "DEV" "DESTINATION" "" ${ARGN})
    if(IRT_DESTINATION)
        set(DEST_IRT ${IRT_DESTINATION})
    else()
        set(DEST_IRT /)
    endif()
    if(IRT_DEV)
        installHeaders()
        install(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME} RUNTIME DESTINATION ${DEST_IRT} ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR} INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
        if(NOT (${CMAKE_PROJECT_NAME} STREQUAL ${PROJECT_NAME}))
            install(EXPORT ${PROJECT_NAME} NAMESPACE ${CMAKE_PROJECT_NAME}:: FILE ${PROJECT_NAME}Config.cmake DESTINATION cmake)
        else()
            install(EXPORT ${PROJECT_NAME} FILE ${PROJECT_NAME}Config.cmake DESTINATION cmake)
        endif()
    else()
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION ${DEST_IRT})
    endif()

    checkInstallFiles()
    copyMinGWLibs()
endmacro()

function(checkInstallFiles)
    get_directory_property(hasParent PARENT_DIRECTORY)
    if(NOT hasParent)
        function(checkInstallFiles2)
            install(CODE "
                set(MAN_FILE ${CMAKE_CURRENT_BINARY_DIR}/install_manifest.txt)
                if(EXISTS \${MAN_FILE})
                    file(READ \${MAN_FILE} files)
                    string(REGEX REPLACE \"\\n\" \";\" files \"\${files}\")
                elseif()
                    set(files \"\")
                endif()
                set(DELETED_D \"\")
                foreach(file \${files})
                    list(FIND CMAKE_INSTALL_MANIFEST_FILES \${file} D_IX)
                    if(NOT (\${D_IX} GREATER_EQUAL 0))
                        list(APPEND DELETED_D \${file})
                        message(\"Deleting file: \${file}\")
                    endif()
                endforeach()
                if(NOT (\"x\${DELETED_D}x\" STREQUAL \"xx\"))
                    file(REMOVE \${DELETED_D})
                endif()
            ")
        endfunction()
        cmake_language(DEFER CALL delayDefer checkInstallFiles2)
    endif()
endfunction()

macro(createMinGWBaseFile)
    if(NOT MW_BASE_FILE)
        set(MW_BASE_FILE ${CMAKE_BINARY_DIR}/MinGWBinCopy.cmake)
        set(EXCL "")
        foreach(lib ${CMAKE_CXX_IMPLICIT_LINK_LIBRARIES})
            string(REPLACE "+" "\\\\+" lib ${lib}) #Escape for regex
            list(APPEND EXCL .*${lib})
        endforeach()
        set(BINZ "")
        foreach(lib ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES})
            list(APPEND BINZ ${lib}/../bin)
        endforeach()
        file(WRITE ${MW_BASE_FILE} "
                file(GET_RUNTIME_DEPENDENCIES
                    EXECUTABLES \${TARGET_FILE_E}
                    RESOLVED_DEPENDENCIES_VAR RESOLVED_DEPS
                    UNRESOLVED_DEPENDENCIES_VAR UNRESOLVED_DEPS
                    POST_EXCLUDE_REGEXES \".*system32/.*\\\\.dll\"
                    DIRECTORIES ${BINZ}
                )
                set(EXCL \"\")
                foreach(dep \${RESOLVED_DEPS})
                    foreach(excl ${EXCL})
                        if(\"\${dep}\" MATCHES \"\${excl}\")
                            list(APPEND EXCL \${dep})
                        endif()
                    endforeach()
                endforeach()
                list(REMOVE_DUPLICATES EXCL)
                foreach(excl \${EXCL})
                    file(INSTALL
                        DESTINATION \"\${DEST_FOLDER}\"
                        FOLLOW_SYMLINK_CHAIN
                        FILES \"\${excl}\"
                    )
                endforeach()
            ")
        unset(EXCL)
        unset(BINZ)
    endif()
endmacro()

macro(copyMinGWLibs)
    if(WIN32 AND NOT MSVC) # Yes you, MinGW....
        createMinGWBaseFile()
        install(CODE "
            set(TARGET_FILE_E $<TARGET_FILE:${PROJECT_NAME}>)
            set(DEST_FOLDER ${CMAKE_INSTALL_PREFIX}/${DEST})
            include(\"${MW_BASE_FILE}\")
        ")
    endif()
endmacro()

macro(importSharedLibraries)
    if(NOT (${CMAKE_VERSION} VERSION_LESS "3.20") AND WIN32)
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_RUNTIME_DLLS:${PROJECT_NAME}> $<TARGET_FILE_DIR:${PROJECT_NAME}> COMMAND_EXPAND_LISTS)
        if(NOT MSVC)
            createMinGWBaseFile()
            add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -DDEST_FOLDER="$<TARGET_FILE_DIR:${PROJECT_NAME}>" -DTARGET_FILE_E=$<TARGET_FILE:${PROJECT_NAME}> -P ${MW_BASE_FILE} COMMAND_EXPAND_LISTS)
        endif()
    endif()
endmacro()

macro(setCentralOutput)
    set_target_properties(${PROJECT_NAME} PROPERTIES ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib" RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/bin")
endmacro()

macro(forceX64)
    if(IGNORE_TARGET_PLATFORM)
        message(STATUS "Disabling target platform check")
    elseif(MSVC AND NOT (${CMAKE_GENERATOR} STREQUAL "Ninja"))
        set(CMAKE_GENERATOR_PLATFORM x64)
    elseif(NOT (${CMAKE_SIZEOF_VOID_P} EQUAL 8))
        message(FATAL_ERROR "Target is not 64 bit.\n This cannot be forced from CMakeLists, so please make sure you are using a x64 toolchain.")
    endif()
endmacro()

function(makeRootCMakeConfig)
    cmake_parse_arguments(MRCC "" "DESTINATION" "FILES" ${ARGN})
    string(TOUPPER ${PROJECT_NAME} PROJ_NAME_UPPER)
    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/Config.cmake.in "
\@PACKAGE_INIT@
set(${PROJ_NAME_UPPER}_INSTALL_DIR \${PACKAGE_PREFIX_DIR})
file(GLOB CONFIG_FILES \"\${CMAKE_CURRENT_LIST_DIR}/*Config.cmake\")
foreach(f \${CONFIG_FILES})
    if(NOT (\${CMAKE_CURRENT_LIST_FILE} STREQUAL \${f}))
        include(\${f})
    endif()
endforeach()
            ")
    include(CMakePackageConfigHelpers)
    if(MRCC_DESTINATION)
        set(DEST_F ${MRCC_DESTINATION})
    else()
        set(DEST_F cmake)
    endif()

    foreach(file ${MRCC_FILES})
        cmake_path(GET file FILENAME file_name)
        configure_file(${file} ${CMAKE_BINARY_DIR}/${file_name} @ONLY)
        install(FILES ${CMAKE_BINARY_DIR}/${file_name} DESTINATION ${DEST_F})
    endforeach()

    configure_package_config_file(${CMAKE_CURRENT_BINARY_DIR}/Config.cmake.in "${CMAKE_BINARY_DIR}/${PROJECT_NAME}Config.cmake" INSTALL_DESTINATION ${DEST_F} NO_SET_AND_CHECK_MACRO NO_CHECK_REQUIRED_COMPONENTS_MACRO)
    install(FILES ${CMAKE_BINARY_DIR}/${PROJECT_NAME}Config.cmake DESTINATION ${DEST_F})
endfunction()

#####################################################
## Libraries
#####################################################

function(useLibrary name)
    if(NOT TARGET ${name})
        message(FATAL_ERROR "${name}  is not a target!")
        return()
    endif()
    cmake_parse_arguments(ULB "PUBLIC;PRIVATE" "" "" ${ARGN})
    if(ULB_PUBLIC AND ULB_PRIVATE)
        message(FATAL_ERROR "Dependency ${name} cannot be public AND private!")
        return()
    endif()
    get_target_property(target_type ${name} TYPE)
    if(ULB_PUBLIC)
        if(${target_type} STREQUAL STATIC_LIBRARY)
            target_link_libraries(${PROJECT_NAME} PRIVATE ${name})
            get_target_property(target_includes ${name} INTERFACE_INCLUDE_DIRECTORIES)
            foreach(target_include ${target_includes})
                target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${target_include}>)
            endforeach()
        else()
            target_link_libraries(${PROJECT_NAME} PUBLIC ${name})
        endif()
    else()
        target_link_libraries(${PROJECT_NAME} PRIVATE ${name})
    endif()
endfunction()

function(useHeaderLibrary name)
    cmake_parse_arguments(UHLB "PRIVATE" "" "" ${ARGN})
    if(UHLB_PRIVATE)
        target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    else()
        target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/libs/${name}/include>)
    endif()
endfunction()

function(useSourceLibrary name)
    cmake_parse_arguments(UHLB "CLOSED" "" "" ${ARGN})
    set(NAME_BASE ${PROJECT_SOURCE_DIR}/libs/${name})
    file(GLOB_RECURSE SRCD ${NAME_BASE}/cpp/*.cpp ${NAME_BASE}/cpp/*.c)
    file(GLOB_RECURSE SRCD_C ${NAME_BASE}/c/*.c)
    target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/headers)
    if(EXISTS ${NAME_BASE}/public)
        target_include_directories(${PROJECT_NAME} PUBLIC $<BUILD_INTERFACE:${NAME_BASE}/public>)
    endif()
    if(NOT UHLB_CLOSED)
        target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/cpp)
        target_include_directories(${PROJECT_NAME} PRIVATE ${NAME_BASE}/c)
    endif()
    set_source_files_properties(${SRCD} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRCD_C} PROPERTIES LANGUAGE C)
    target_sources(${PROJECT_NAME} PRIVATE ${SRCD})
    target_sources(${PROJECT_NAME} PRIVATE ${SRCD_C})
endfunction()

function(createStaticLibrary name)
    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        cmake_parse_arguments(CSL "USE;PUBLIC;GLOBAL" "LIB;LIBD" "" ${ARGN})
        if(CSL_GLOBAL)
            add_library(${name} STATIC IMPORTED GLOBAL)
        else()
            add_library(${name} STATIC IMPORTED)
        endif()
        if(EXISTS "${csl_root}/include")
            set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")
        endif()

        if(CSL_LIB)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${CSL_LIB}.lib")
        else()
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${name}.lib")
        endif()

        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        message(FATAL_ERROR "TODO: StaticLibNonMSVC")
    endif()
endfunction()

function(createSharedLibrary name)
    cmake_parse_arguments(CSL "USE;PUBLIC;GLOBAL" "DLL;LIB;DLLD;LIBD;FILE;FILED;INSTALL;NAME" "DEPENDENCIES;COMPONENTS" ${ARGN})
    if(CSL_PUBLIC)
        set(PUB PUBLIC)
    else()
        set(PUB PRIVATE)
    endif()
    if(CSL_INSTALL)
        set(INSTALL ${CSL_INSTALL})
    else()
        set(INSTALL "|")
    endif()

    testPackage(${name})
    if(${${name}__FOUND})
        find_package(${name} REQUIRED ${CSL_COMPONENTS})
        message("${name} FOUND")
        if(CSL_USE)
            if(CSL_NAME)
                set(name ${CSL_NAME})
            endif()
            if(CSL_COMPONENTS)
                foreach(cmp ${CSL_COMPONENTS})
                    useLibInternal(${name}::${cmp} ${PUB} ${INSTALL})
                endforeach()
            else()
                useLibInternal(${name} ${PUB} ${INSTALL})
            endif()
        endif()
        return()
    endif()

    if(WIN32)
        find_library(UIDL uuid HINTS ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES})
    endif()

    if(MSVC)
        message("${name} NOT FOUND -> Hardsearch")
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        if(CSL_GLOBAL)
            add_library(${name} SHARED IMPORTED GLOBAL)
        else()
            add_library(${name} SHARED IMPORTED)
        endif()

        if(CSL_DEPENDENCIES)
            set_target_properties(${name} PROPERTIES INTERFACE_LINK_LIBRARIES ${CSL_DEPENDENCIES})
        endif()

        if(EXISTS "${csl_root}/include")
            set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")
        endif()

        if(CSL_DLL)
            set(CSL_DLL_FILE ${CSL_DLL}.dll)
        else()
            if(CSL_FILE)
                set(CSL_DLL_FILE ${CSL_FILE}.dll)
            else()
                set(CSL_DLL_FILE ${name}.dll)
            endif()
        endif()
        set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/bin/${CSL_DLL_FILE}")
        if(CSL_INSTALL)
            install(FILES "${csl_root}/bin/${CSL_DLL_FILE}" DESTINATION ${CSL_INSTALL})
        endif()

        if(CSL_LIB)
            set(CSL_LIB_FILE ${CSL_LIB}.lib)
        else()
            if(CSL_FILE)
                set(CSL_LIB_FILE ${CSL_FILE}.lib)
            else()
                set(CSL_LIB_FILE ${name}.lib)
            endif()
        endif()
        if(EXISTS "${csl_root}/lib/${CSL_LIB_FILE}")
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB "${csl_root}/lib/${CSL_LIB_FILE}")
        else()
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB ${UIDL}) # Jokes on you
            #set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB NOTFOUND)
        endif()

        if(CSL_DLLD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_DLLD}.dll")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_FILED}.dll")
        endif()
        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_FILED}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        message("${name} NOT FOUND -> PKG")
        pkg_search_module(${name} REQUIRED ${name})
        if(CSL_GLOBAL)
            add_library(${name} SHARED IMPORTED GLOBAL)
        else()
            add_library(${name} SHARED IMPORTED)
        endif()

        if(${name}_INCLUDE_DIRS)
            set_property(TARGET ${name} PROPERTY INTERFACE_INCLUDE_DIRECTORIES "${${name}_INCLUDE_DIRS}")
        endif()
        if(${name}_LINK_LIBRARIES)
            set_property(TARGET ${name} PROPERTY INTERFACE_LINK_LIBRARIES "${${name}_LINK_LIBRARIES}")
        endif()
        if(${name}_LDFLAGS_OTHER)
            set_property(TARGET ${name} PROPERTY INTERFACE_LINK_OPTIONS "${${name}_LDFLAGS_OTHER}")
        endif()
        if(${name}_CFLAGS_OTHER)
            set_property(TARGET ${name} PROPERTY INTERFACE_COMPILE_OPTIONS "${${name}_CFLAGS_OTHER}")
        endif()

        if(WIN32)
            set_property(TARGET ${name} PROPERTY IMPORTED_IMPLIB ${UIDL}) # Jokes on you
        endif()

        if(CSL_USE)
            useLibrary(${name} ${PUB})
        endif()

        if(WIN32)
            find_file(TESTVALPR_${name} NAMES "${CSL_DLL}.dll" "${CSL_FILE}.dll" "${name}.dll" "lib${CSL_DLL}.dll" "lib${CSL_FILE}.dll" "lib${name}.dll" PATHS ${CMAKE_C_IMPLICIT_LINK_DIRECTORIES} REQUIRED)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${TESTVALPR_${name}}")
            if(CSL_INSTALL)
                install(FILES "${TESTVALPR_${name}}" DESTINATION ${CSL_INSTALL})
            endif()
        endif()
    endif()
endfunction()

function(useLibInternal name pub install)
    useLibrary(${name} ${pub})
    if(NOT (${install} STREQUAL "|") AND WIN32)
        get_target_property(TPROPS ${name} IMPORTED_CONFIGURATIONS)
        string(TOLOWER ${CMAKE_BUILD_TYPE} cbt)
        foreach(cfg ${TPROPS})
            string(TOLOWER ${cfg} cfgl)
            if(${cfgl} STREQUAL ${cbt})
                set(ICTY ${cfg})
            endif()
        endforeach()
        if(NOT ICTY)
            foreach(cfg ${TPROPS})
                string(TOLOWER ${cfg} cfgl)
                if(${cfgl} STREQUAL release)
                    set(ICTY ${cfg})
                endif()
            endforeach()
        endif()
        if(NOT ICTY)
            message(FATAL_ERROR "No valid build-types in dependency: ${name}")
        endif()
        get_target_property(TPROPS ${name} IMPORTED_LOCATION_${ICTY})
        install(FILES "${TPROPS}" DESTINATION ${install})
    endif()
endfunction()

#####################################################
## GTest
#####################################################

macro(fetchGTest)
    if(NOT DEFINED ENABLE_UNIT_TESTS)
        option(ENABLE_UNIT_TESTS "Enable unit tests" ON)
    endif()
    message(STATUS "Enable testing: ${ENABLE_UNIT_TESTS}")
    if(ENABLE_UNIT_TESTS)
        include(FetchContent)
        cmake_parse_arguments(AGT "" "FILE;VERSION" "" ${ARGN})
        if(AGT_VERSION)
            FetchContent_Declare(googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG ${AGT_VERSION})
        elseif(AGT_FILE)
            FetchContent_Declare(googletest URL file://${PROJECT_SOURCE_DIR}/${AGT_FILE})
        else()
            message(FATAL_ERROR "Invalid GTest fetch arguments")
        endif()
        # For Windows: Prevent overriding the parent project's compiler/linker settings
        set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
        set(BUILD_GMOCK OFF CACHE BOOL "" FORCE)
        set(BUILD_GTEST ON CACHE BOOL "" FORCE)
        option(INSTALL_GMOCK OFF)
        option(INSTALL_GTEST OFF)
        FetchContent_MakeAvailable(googletest)
        message(STATUS "GoogleTest has been enabled")
    endif()
endmacro()

macro(addTest)
    if(ENABLE_UNIT_TESTS)
        set(TEST_P_NAME ${PROJECT_NAME}_test)
        file(GLOB_RECURSE TEST_SRC test/*.cpp test/*.c test/*.hpp test/*.h)

        add_executable(${TEST_P_NAME} ${TEST_SRC})

        target_link_libraries(${TEST_P_NAME} PRIVATE ${PROJECT_NAME} gtest_main)
        foreach(arg IN LISTS ARGN)
            target_link_libraries(${TEST_P_NAME} PRIVATE ${arg})
        endforeach()

        enable_testing()
        add_test(NAME ${TEST_P_NAME} COMMAND ${TEST_P_NAME})
    endif()
endmacro()