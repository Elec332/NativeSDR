include(CMakeParseArguments)

function(addProject type)
    getSources()

    #Lib type mapper
    if ((${type} STREQUAL LIB) OR (${type} STREQUAL LIBRARY))
        if ((DEFINED ARGV1) AND ((${ARGV1} STREQUAL SHARED) OR (${ARGV1} STREQUAL STATIC)))
            set(type ${ARGV1})
        else()
            message(FATAL_ERROR "No/invalid lib type defined")
        endif()
    endif()

    #Lib or executable
    if ((${type} STREQUAL SHAREDLIB) OR (${type} STREQUAL SHARED))
        add_library(${PROJECT_NAME} SHARED ${SRC} ${SRC_C})
        withExportHeaders()
        importSharedLibraries()
    elseif((${type} STREQUAL STATICLIB) OR (${type} STREQUAL STATIC))
        add_library(${PROJECT_NAME} STATIC ${SRC} ${SRC_C})
    elseif(${type} STREQUAL EXEC)
        add_executable(${PROJECT_NAME} ${SRC} ${SRC_C})
        importSharedLibraries()
    else()
        message(FATAL_ERROR "Invalid project type: ${type}")
    endif ()

    addIncludeDirectories()
    processAssets(assets)
endfunction()

macro(getSources)
    file(GLOB_RECURSE SRC src/cpp/*.cpp src/cpp/*.c src/cpp/*.hpp src/cpp/*.h)
    file(GLOB_RECURSE SRC_C src/cpp/*.c src/c/*.h)
    set_source_files_properties(${SRC} PROPERTIES LANGUAGE CXX)
    set_source_files_properties(${SRC_C} PROPERTIES LANGUAGE C)
endmacro()

macro(addIncludeDirectories)
    target_include_directories(${PROJECT_NAME} PRIVATE src/headers)
    target_include_directories(${PROJECT_NAME} PUBLIC src/public)
endmacro()

macro(processAssets)
    if(DEFINED ARGV0)
        set(ASSET_DIR ${ARGV0})
    endif()
    if(NOT DEFINED ASSET_DIR)
        set(ASSET_DIR assets)
    endif()
    #todo: Force-overwrite assets. Install DIRECTORY doesnt do this, but install FILES doesnt do so either
    if(EXISTS ${PROJECT_SOURCE_DIR}/assets/)
        file(GLOB files "assets/*.*")
        set(ASSET_OUTPUTS)
        foreach(file ${files})
            cmake_path(GET file FILENAME file_name)
            set(FNDR ${${PROJECT_NAME}_BINARY_DIR}/${ASSET_DIR}/${file_name})
            add_custom_command(OUTPUT ${FNDR} COMMAND ${CMAKE_COMMAND} -E copy_if_different ${file} ${FNDR} DEPENDS ${file})
            list(APPEND ASSET_OUTPUTS ${FNDR})
            install(FILES ${FNDR} DESTINATION ${ASSET_DIR})
        endforeach()
        add_custom_target(${PROJECT_NAME}_assets DEPENDS ${ASSET_OUTPUTS})
        add_dependencies(${PROJECT_NAME} ${PROJECT_NAME}_assets)
    endif()
endmacro()

macro(withExportHeaders)
    include(GenerateExportHeader)
    generate_export_header(${PROJECT_NAME})
    target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_BINARY_DIR})
endmacro()

function(installRuntime)
    if (DEFINED ARGV0)
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION ${ARGV0})
    else()
        install(TARGETS ${PROJECT_NAME} RUNTIME DESTINATION /)
    endif()
endfunction()

macro(setCentralOutput)
    SET(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
    SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
    SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
endmacro()

macro(importSharedLibraries)
    if(NOT (${CMAKE_VERSION} VERSION_LESS "3.20"))
        add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_RUNTIME_DLLS:${PROJECT_NAME}> $<TARGET_FILE_DIR:${PROJECT_NAME}> COMMAND_EXPAND_LISTS)
    endif()
endmacro()

macro(forceX64)
    if(IGNORE_TARGET_PLATFORM)
        message(STATUS "Disabling target platform check")
    elseif(MSVC AND NOT (${CMAKE_GENERATOR} STREQUAL "Ninja"))
        set(CMAKE_GENERATOR_PLATFORM x64)
    elseif(NOT (${CMAKE_SIZEOF_VOID_P} EQUAL 8))
        message(FATAL_ERROR "Target is not 64 bit.\n This cannot be forced from CMakeLists, so please make sure you are using a x64 toolchain.")
    endif()
endmacro()

#####################################################
## Libraries
#####################################################

function(useLibrary name)
    if(NOT TARGET ${name})
        message(FATAL_ERROR ${name} " is not a target!")
        return()
    endif()
    cmake_parse_arguments(ULB "PUBLIC" "" "" ${ARGN})
    get_target_property(target_type ${name} TYPE)
    if(ULB_PUBLIC)
        if(${target_type} STREQUAL STATIC_LIBRARY)
            target_link_libraries(${PROJECT_NAME} PRIVATE ${name})
            get_target_property(target_includes ${name} INTERFACE_INCLUDE_DIRECTORIES)
            foreach(target_include ${target_includes})
                target_include_directories(${PROJECT_NAME} PUBLIC ${target_include})
            endforeach()
        else()
            target_link_libraries(${PROJECT_NAME} PUBLIC ${name})
        endif()
    else()
        target_link_libraries(${PROJECT_NAME} PRIVATE ${name})
    endif()
endfunction()

function(useHeaderLibrary name)
    cmake_parse_arguments(UHLB "PRIVATE" "" "" ${ARGN})
    if(UHLB_PRIVATE)
        target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    else()
        target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/libs/${name}/include)
    endif()
endfunction()

function(createStaticLibrary name)
    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        cmake_parse_arguments(CSL "USE;PUBLIC;GLOBAL" "LIB;LIBD" "" ${ARGN})
        if(CSL_GLOBAL)
            add_library(${name} STATIC IMPORTED GLOBAL)
        else()
            add_library(${name} STATIC IMPORTED)
        endif()
        if(EXISTS "${csl_root}/include")
            set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")
        endif()

        if(CSL_LIB)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${CSL_LIB}.lib")
        else()
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/lib/${name}.lib")
        endif()

        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        #todo: Linux ect
    endif()
endfunction()

function(createSharedLibrary name)
    if(MSVC)
        set(csl_root ${PROJECT_SOURCE_DIR}/libs/${name})
        cmake_parse_arguments(CSL "USE;PUBLIC;GLOBAL" "DLL;LIB;DLLD;LIBD;FILE;FILED;INSTALL" "DEPENDENCIES" ${ARGN})
        if(CSL_GLOBAL)
            add_library(${name} SHARED IMPORTED GLOBAL)
        else()
            add_library(${name} SHARED IMPORTED)
        endif()

        if(CSL_DEPENDENCIES)
            set_target_properties(${name} PROPERTIES INTERFACE_LINK_LIBRARIES ${CSL_DEPENDENCIES})
        endif()

        if(EXISTS "${csl_root}/include")
            set_target_properties(${name} PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${csl_root}/include")
        endif()

        if(CSL_DLL)
            set(CSL_DLL_FILE ${CSL_DLL}.dll)
        else()
            if(CSL_FILE)
                set(CSL_DLL_FILE ${CSL_FILE}.dll)
            else()
                set(CSL_DLL_FILE ${name}.dll)
            endif()
        endif()
        set_target_properties(${name} PROPERTIES IMPORTED_LOCATION "${csl_root}/bin/${CSL_DLL_FILE}")
        if(CSL_INSTALL)
            install(FILES "${csl_root}/bin/${CSL_DLL_FILE}" DESTINATION ${CSL_INSTALL})
        endif()

        if(CSL_LIB)
            set(CSL_LIB_FILE ${CSL_LIB}.lib)
        else()
            if(CSL_FILE)
                set(CSL_LIB_FILE ${CSL_FILE}.lib)
            else()
                set(CSL_LIB_FILE ${name}.lib)
            endif()
        endif()
        if(EXISTS "${csl_root}/lib/${CSL_LIB_FILE}")
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB "${csl_root}/lib/${CSL_LIB_FILE}")
        else()
            find_library(UIDL uuid)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB ${UIDL}) # Jokes on you
#            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB NOTFOUND)
        endif()

        if(CSL_DLLD)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_DLLD}.dll")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_LOCATION_DEBUG "${csl_root}/bin/${CSL_FILED}.dll")
        endif()
        if(CSL_LIBD)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_LIBD}.lib")
        elseif(CSL_FILED)
            set_target_properties(${name} PROPERTIES IMPORTED_IMPLIB_DEBUG "${csl_root}/lib/${CSL_FILED}.lib")
        endif()

        if(CSL_USE)
            if(CSL_PUBLIC)
                useLibrary(${name} PUBLIC)
            else()
                useLibrary(${name})
            endif()
        endif()
    else()
        #todo: Linux ect
    endif()
endfunction()

#####################################################
## GTest
#####################################################

macro(fetchGTest)
    if (NOT DEFINED ENABLE_UNIT_TESTS)
        option(ENABLE_UNIT_TESTS "Enable unit tests" ON)
    endif()
    message(STATUS "Enable testing: ${ENABLE_UNIT_TESTS}")
    if (ENABLE_UNIT_TESTS)
        include(FetchContent)
        cmake_parse_arguments(AGT "" "FILE;VERSION" "" ${ARGN})
        if(AGT_VERSION)
            FetchContent_Declare(googletest GIT_REPOSITORY https://github.com/google/googletest.git GIT_TAG ${AGT_VERSION})
        elseif(AGT_FILE)
            FetchContent_Declare(googletest URL file://${PROJECT_SOURCE_DIR}/${AGT_FILE})
        else()
            message(FATAL_ERROR "Invalid GTest fetch arguments")
        endif()
        # For Windows: Prevent overriding the parent project's compiler/linker settings
        set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)
        set(BUILD_GMOCK OFF CACHE BOOL "" FORCE)
        set(BUILD_GTEST ON CACHE BOOL "" FORCE)
        option(INSTALL_GMOCK OFF)
        option(INSTALL_GTEST OFF)
        FetchContent_MakeAvailable(googletest)
        message(STATUS "GoogleTest has been enabled")
    endif()
endmacro()

macro(addTest)
    if (ENABLE_UNIT_TESTS)
        set(TEST_P_NAME ${PROJECT_NAME}_test)
        file(GLOB_RECURSE TEST_SRC test/*.cpp test/*.c test/*.hpp test/*.h)

        add_executable(${TEST_P_NAME} ${TEST_SRC})

        target_link_libraries(${TEST_P_NAME} PRIVATE ${PROJECT_NAME} gtest_main)
        foreach(arg IN LISTS ARGN)
            target_link_libraries(${TEST_P_NAME} PRIVATE ${arg})
        endforeach()

        enable_testing()
        add_test(NAME ${TEST_P_NAME} COMMAND ${TEST_P_NAME})
    endif()
endmacro()